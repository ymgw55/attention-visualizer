<!-- Debug-monolith: single-file index.html (4 heads, 6 tokens, sliding window) -->
<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Attention Visualizer</title>
  <!-- Analytics -->
  <script async src="https://analytics.umami.is/script.js"
    data-website-id="e4c0540b-ef70-4ae4-863a-887b7841211b"></script>
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <style>
    body {
      font-family: system-ui, -apple-system, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
      margin: 0;
      padding: 1rem;
      background: #fafafa;
    }

    #controls {
      display: flex;
      flex-wrap: wrap;
      gap: 1rem;
      align-items: center;
      margin-bottom: 1rem;
    }

    #controls button,
    #controls select {
      padding: 0.4rem 0.8rem;
      border: 1px solid #8884;
      border-radius: 4px;
      background: #fff;
      font-size: .9rem;
      cursor: pointer;
    }

    #controls button:hover,
    #controls select:hover {
      background: #f0f0f0;
    }

    #step-display {
      font-weight: 600;
      font-size: 1.3rem;
    }

    #container {
      overflow-x: auto;
      border: 1px solid #ddd;
      background: #fff;
      padding: 1rem;
      border-radius: 6px;
      box-shadow: 0 2px 4px rgba(0, 0, 0, .08);
    }

    /* highlight colours */
    .q-highlight {
      fill: #3e63dd !important;
    }

    .k-highlight {
      fill: #f15353 !important;
    }

    .v-highlight {
      fill: #e2b75a !important;
    }

    .m-highlight {
      fill: #802dc4 !important;
    }

    .o-highlight {
      fill: #2aa85a !important;
    }

    /* cache colours (pale) */
    .k-cache {
      fill: #f0b6b6 !important;
    }

    .v-cache {
      fill: #ffe9a8 !important;
    }

    .m-cache {
      fill: #d9b8ff !important;
    }

    /* cache pattern overlay */
    .cache-overlay {
      fill: url(#cache-pattern) !important;
      stroke: none !important;
      pointer-events: none;
      mix-blend-mode: multiply;
    }

    /* cache pattern overlay in opacity mode - more subtle */
    .cache-overlay.opacity-mode {
      opacity: 0.3;
      mix-blend-mode: normal;
    }

    /* masked (future) attention weights */
    .masked {
      fill: #c0c0c0 !important;
      stroke: #999 !important;
    }

    .fade {
      opacity: .25;
    }

    line.arrow {
      stroke: #555;
      stroke-width: 1.6;
      marker-end: url(#arrowhead);
    }

    #header-links {
      position: absolute;
      top: 1rem;
      right: 1rem;
      display: flex;
      flex-direction: column;
      gap: 0.2rem;
      font-size: 0.9rem;
    }

    #header-links a {
      color: #666;
      text-decoration: none;
      padding: 0.3rem 0.6rem;
      border-radius: 4px;
      transition: background-color 0.2s;
    }

    #header-links a:hover {
      background-color: #f0f0f0;
      color: #333;
    }
  </style>
</head>

<body>
  <div id="header-links">
    <a href="https://github.com/ymgw55/attention-visualizer" target="_blank">GitHub</a>
    <a href="https://ymgw55.github.io/" target="_blank">Hiroaki Yamagiwa</a>
  </div>
  <h2 style="margin:0"><a href="#" onclick="location.reload(); return false;"
      style="color:inherit;text-decoration:none;cursor:pointer">Attention Visualizer</a></h2>
  <p style="margin:.2rem 0 .8rem 0">Heads=4, Tokens=6 (fixed)</p>
  <p id="mask-explanation" style="margin:.5rem 0 .5rem 0;font-size:.85rem;color:#666;">
    <strong>Attention Masks:</strong> Gray areas (future & out-of-window)
  </p>
  <p id="cache-explanation" style="margin:.5rem 0 1rem 0;font-size:.85rem;color:#666;visibility:hidden">
    <strong>KV Cache:</strong> Hatched areas (
    <svg width="12" height="12" style="vertical-align:middle;margin:0 2px">
      <defs>
        <pattern id="mini-cache-pattern" patternUnits="userSpaceOnUse" width="8" height="8">
          <rect width="8" height="8" fill="white" />
          <path d="M0,8 l8,-8 M-1,1 l2,-2 M7,9 l2,-2" stroke="#333" stroke-width="1.0" stroke-opacity="0.6" />
        </pattern>
      </defs>
      <rect width="12" height="12" fill="url(#mini-cache-pattern)" stroke="#333" />
    </svg>
    )
  </p>
  <div id="controls">
    <span id="step-display">Step: 1</span>
    <button id="play-btn">⏸ Pause</button>
    <button id="opacity-btn">Opacity: OFF</button>
    <button id="cache-btn">KV Cache: OFF</button>
    <label>KV Heads:
      <select id="groups-select">
        <option value="4" selected>4 (MHA)</option>
        <option value="2">2 (GQA)</option>
        <option value="1">1 (MQA)</option>
      </select>
    </label>
    <label>Sliding Window:
      <select id="window-select">
        <option value="all" selected>all</option>
        <option value="5">5</option>
        <option value="4">4</option>
        <option value="3">3</option>
        <option value="2">2</option>
        <option value="1">1</option>
      </select>
    </label>
    <label>Attention Sinks:
      <select id="sinks-select" disabled>
        <option value="0" selected>0</option>
      </select>
    </label>
  </div>
  <div id="container"></div>

  <script>
    /************** Configuration **************/
    const HEADS = 4, TOKENS = 6, CELL = 28, ROW_H = CELL, W_QVO = CELL * 2, H_QVO = ROW_H, W_K = CELL, H_K = ROW_H * 2, PAD_H = 64, HEAD_MARGIN = 32, HEAD_HEIGHT = TOKENS * ROW_H;

    /************** Runtime **************/
    let groups = 4, step = 0, playing = true, kvCache = false, winSetting = 'all', attentionSinks = 0, opacityMode = false;

    // Predefined opacity values for each query (6 queries, 4 heads)
    const queryOpacities = [
      [1.0, 0.2, 0.7, 0.4], // q1: head1, head2, head3, head4
      [0.3, 0.9, 0.1, 0.6], // q2
      [0.8, 0.1, 1.0, 0.3], // q3
      [0.2, 0.8, 0.4, 1.0], // q4
      [0.9, 0.3, 0.6, 0.1], // q5
      [0.4, 1.0, 0.2, 0.8]  // q6
    ];

    // Predefined opacity values for each key (6 keys, 4 heads)
    const keyOpacities = [
      [0.7, 0.8, 0.9, 0.5], // k1: head1, head2, head3, head4
      [0.2, 0.6, 0.4, 0.7], // k2
      [0.1, 0.1, 0.8, 0.3], // k3
      [0.8, 0.5, 0.2, 0.1], // k4
      [0.3, 0.3, 0.1, 0.8], // k5
      [0.4, 0.2, 0.7, 0.4]  // k6
    ];

    // Predefined opacity values for each value (6 values, 4 heads)
    const valueOpacities = [
      [0.4, 0.5, 0.3, 0.6], // v1: head1, head2, head3, head4
      [0.8, 0.8, 1.0, 0.4], // v2
      [0.5, 0.3, 0.1, 0.9], // v3
      [1.0, 0.7, 0.6, 0.2], // v4
      [0.2, 0.1, 0.9, 0.5], // v5
      [0.7, 0.9, 0.4, 1.0]  // v6
    ];

    // Random constant terms for each query (6 queries, 4 heads) - all positive values
    const queryConstants = [
      [0.5, 0.5, 0.5, 0.5], // c1: head1, head2, head3, head4
      [0.02, 0.03, 0.04, 0.03], // c2
      [0.01, 0.02, 0.03, 0.04], // c3
      [0.02, 0.03, 0.04, 0.05], // c4
      [0.03, 0.04, 0.05, 0.02], // c5
      [0.01, 0.01, 0.02, 0.03]  // c6
    ];

    // Function to compute attention opacities for a given head
    function computeAttentionOpacities(head, currentStep, windowSize, attentionSinks) {
      const opacities = Array(TOKENS).fill(null).map(() => Array(TOKENS).fill(0));

      // Determine which head's key/query values to use based on groups setting
      let keyHeadIndex, queryHeadIndex;
      if (groups === 4) {
        // MHA: use head index directly
        keyHeadIndex = head;
        queryHeadIndex = head;
      } else if (groups === 2) {
        // GQA: head 1,2 use head1 (index 0), head 3,4 use head3 (index 2)
        const groupIndex = Math.floor(head / 2);
        keyHeadIndex = groupIndex === 0 ? 0 : 2;
        queryHeadIndex = head;
      } else if (groups === 1) {
        // MQA: all heads use head1 (index 0)
        keyHeadIndex = 0;
        queryHeadIndex = head;
      }

      for (let r = 0; r <= currentStep; r++) {
        const attentionRow = [];
        let sum = 0;

        // First pass: compute raw attention values and identify non-masked positions
        for (let c = 0; c < TOKENS; c++) {
          // Check if this position should be masked
          const isFuture = c > r;
          const windowStart = Math.max(0, r - windowSize + 1);
          const isOutOfWindow = windowSize !== Infinity && c < windowStart;
          const isInAttentionSinks = windowSize !== Infinity && c < attentionSinks;

          if (isFuture || (isOutOfWindow && !isInAttentionSinks)) {
            attentionRow[c] = 0; // Masked position
          } else {
            // Compute attention: q_i * k_j + c_i (no max needed since constants are positive)
            const q_i = queryOpacities[r][queryHeadIndex];
            const k_j = keyOpacities[c][keyHeadIndex];
            const c_i = queryConstants[r][queryHeadIndex];
            const attention = q_i * k_j + c_i;
            attentionRow[c] = attention;
            sum += attention; // Only add non-masked values to sum
          }
        }

        // Second pass: normalize only non-masked positions so their sum equals 1
        if (sum > 0) {
          for (let c = 0; c < TOKENS; c++) {
            if (attentionRow[c] > 0) { // Only normalize non-masked positions
              opacities[r][c] = attentionRow[c] / sum;
            }
          }
        }
      }

      return opacities;
    }

    // Function to compute output values for all heads and all steps
    function computeAllOutputOpacities(windowSize, attentionSinks) {
      const tau = 0.25; // Temperature parameter for output normalization
      const allOutputs = [];

      // Compute outputs for all heads and all steps
      for (let h = 0; h < HEADS; h++) {
        const headOutputs = [];

        // Determine which head's value index to use based on groups setting
        let valueHeadIndex;
        if (groups === 4) {
          // MHA: use head index directly
          valueHeadIndex = h;
        } else if (groups === 2) {
          // GQA: head 1,2 use head1 (index 0), head 3,4 use head3 (index 2)
          const groupIndex = Math.floor(h / 2);
          valueHeadIndex = groupIndex === 0 ? 0 : 2;
        } else if (groups === 1) {
          // MQA: all heads use head1 (index 0)
          valueHeadIndex = 0;
        }

        // Get attention weights for this head
        const attentionWeights = computeAttentionOpacities(h, TOKENS - 1, windowSize, attentionSinks);

        for (let r = 0; r < TOKENS; r++) {
          let outputValue = 0;

          // Calculate sum of (attention_weight * value) for non-masked positions
          for (let c = 0; c < TOKENS; c++) {
            if (attentionWeights[r][c] > 0) { // Only non-masked positions
              const attentionWeight = attentionWeights[r][c];
              const valueOpacity = valueOpacities[c][valueHeadIndex];
              outputValue += attentionWeight * valueOpacity;
            }
          }

          headOutputs.push(outputValue);
        }

        allOutputs.push(headOutputs);
      }

      // Find maximum output value across all heads and steps
      let maxOutput = -Infinity;
      for (let h = 0; h < HEADS; h++) {
        for (let r = 0; r < TOKENS; r++) {
          maxOutput = Math.max(maxOutput, allOutputs[h][r]);
        }
      }

      // Apply exp((output - max) / tau) normalization with temperature
      const normalizedOutputs = [];
      for (let h = 0; h < HEADS; h++) {
        const normalizedHeadOutputs = [];
        for (let r = 0; r < TOKENS; r++) {
          const normalizedValue = Math.exp((allOutputs[h][r] - maxOutput) / tau);
          normalizedHeadOutputs.push(normalizedValue);
        }
        normalizedOutputs.push(normalizedHeadOutputs);
      }

      return normalizedOutputs;
    }

    /************** D3 roots **************/
    const container = d3.select('#container');
    let svg, timer;
    let X = {};

    function computeX() {
      X.Q = 60; // Add left margin for head labels
      X.K = X.Q + W_QVO + PAD_H;
      X.M = X.K + TOKENS * W_K + PAD_H;
      X.V = X.M + TOKENS * CELL + PAD_H;
      X.O = X.V + W_QVO + PAD_H;
      X.W = X.O + W_QVO + 20; // Add extra margin for "Attention" label
    }

    const qCenterY = y => y + TOKENS / 2 * ROW_H;

    /************** Helpers **************/
    function clearSvg() {
      svg && svg.remove();
    }

    function block(g, x, y, w, h, lab, cls, r = null, c = null) {
      const rect = g.append('rect')
        .attr('x', x)
        .attr('y', y)
        .attr('width', w)
        .attr('height', h)
        .attr('fill', '#fff')
        .attr('stroke', '#bbb')
        .attr('class', `${cls} rect`)
        .attr('data-r', r)
        .attr('data-c', c);

      // Add overlay rect for cache pattern
      g.append('rect')
        .attr('x', x)
        .attr('y', y)
        .attr('width', w)
        .attr('height', h)
        .attr('class', `${cls} cache-overlay`)
        .attr('data-r', r)
        .attr('data-c', c)
        .style('display', 'none');

      if (lab) {
        g.append('text')
          .attr('x', x + w / 2)
          .attr('y', y + h / 2)
          .attr('text-anchor', 'middle')
          .attr('dominant-baseline', 'middle')
          .attr('font-size', 12)
          .text(lab);
      }
    }

    function addA(g, x1, y1, x2, y2) {
      g.append('line')
        .attr('class', 'arrow')
        .attr('x1', x1)
        .attr('y1', y1)
        .attr('x2', x2)
        .attr('y2', y2);
    }

    const win = () => winSetting === 'all' ? Infinity : +winSetting;

    /************** Layout **************/
    function drawLayout() {
      clearSvg();
      computeX();

      const H = HEAD_HEIGHT * HEADS + HEAD_MARGIN * (HEADS - 1);
      svg = container.append('svg')
        .attr('width', X.W)
        .attr('height', H + 30); // Add extra height for section labels

      // Add section labels at the top
      const labelY = 15;
      svg.append('text')
        .attr('x', X.Q + W_QVO / 2)
        .attr('y', labelY)
        .attr('text-anchor', 'middle')
        .attr('font-size', 14)
        .attr('font-weight', 'bold')
        .attr('fill', '#333')
        .text('Queries');

      svg.append('text')
        .attr('x', X.K + TOKENS * W_K / 2)
        .attr('y', labelY)
        .attr('text-anchor', 'middle')
        .attr('font-size', 14)
        .attr('font-weight', 'bold')
        .attr('fill', '#333')
        .text('Keys');

      svg.append('text')
        .attr('x', X.M + TOKENS * CELL / 2)
        .attr('y', labelY)
        .attr('text-anchor', 'middle')
        .attr('font-size', 14)
        .attr('font-weight', 'bold')
        .attr('fill', '#333')
        .text('Attention Weight');

      svg.append('text')
        .attr('x', X.V + W_QVO / 2)
        .attr('y', labelY)
        .attr('text-anchor', 'middle')
        .attr('font-size', 14)
        .attr('font-weight', 'bold')
        .attr('fill', '#333')
        .text('Values');

      svg.append('text')
        .attr('x', X.O + W_QVO / 2)
        .attr('y', labelY)
        .attr('text-anchor', 'middle')
        .attr('font-size', 14)
        .attr('font-weight', 'bold')
        .attr('fill', '#333')
        .text('Attention');

      svg.append('defs')
        .append('marker')
        .attr('id', 'arrowhead')
        .attr('viewBox', '0 0 10 10')
        .attr('refX', 10)
        .attr('refY', 5)
        .attr('markerWidth', 6)
        .attr('markerHeight', 6)
        .attr('orient', 'auto')
        .append('path')
        .attr('d', 'M0 0 L10 5 L0 10 z')
        .attr('fill', '#555');

      // Add patterns for cache visualization
      const defs = svg.select('defs');

      const pattern = defs.append('pattern')
        .attr('id', 'cache-pattern')
        .attr('patternUnits', 'userSpaceOnUse')
        .attr('width', 8)
        .attr('height', 8);

      pattern.append('rect')
        .attr('width', 8)
        .attr('height', 8)
        .attr('fill', 'white')
        .attr('fill-opacity', 0);

      pattern.append('path')
        .attr('d', 'M0,8 l8,-8 M-1,1 l2,-2 M7,9 l2,-2')
        .attr('stroke', '#000')
        .attr('stroke-width', 1.2)
        .attr('stroke-opacity', 0.9);

      const hpg = HEADS / groups, meta = [];
      for (let g = 0; g < groups; g++) {
        const h0 = g * hpg, h1 = h0 + hpg - 1;
        const yT = h0 * (HEAD_HEIGHT + HEAD_MARGIN) + 30, yB = h1 * (HEAD_HEIGHT + HEAD_MARGIN) + HEAD_HEIGHT + 30;
        meta.push({ kC: (yT + yB) / 2, vT: (yT + yB) / 2 - TOKENS * H_QVO / 2, h0, h1 });
      }

      for (let h = 0; h < HEADS; h++) {
        const y = h * (HEAD_HEIGHT + HEAD_MARGIN) + 30, gh = svg.append('g').attr('class', `head h${h}`); // Add 30px offset for labels

        // Add head label
        gh.append('text')
          .attr('x', 50)
          .attr('y', y + HEAD_HEIGHT / 2)
          .attr('text-anchor', 'end')
          .attr('dominant-baseline', 'middle')
          .attr('font-size', 14)
          .attr('font-weight', 'bold')
          .attr('fill', '#333')
          .text(`Head ${h + 1}`);

        for (let r = 0; r < TOKENS; r++) {
          block(gh, X.Q, y + r * ROW_H, W_QVO, H_QVO, `q${r + 1}`, 'q', r);
        }

        for (let r = 0; r < TOKENS; r++) {
          for (let c = 0; c < TOKENS; c++) {
            block(gh, X.M + c * CELL, y + r * CELL, CELL, CELL, '', 'm', r, c);
          }
        }

        for (let r = 0; r < TOKENS; r++) {
          block(gh, X.O, y + r * ROW_H, W_QVO, H_QVO, `o${r + 1}`, 'o', r);
        }
      }

      meta.forEach((m, i) => {
        const g = svg.append('g').attr('class', `kv g${i}`);
        const yK = m.kC - H_K / 2;

        for (let c = 0; c < TOKENS; c++) {
          block(g, X.K + c * W_K, yK, W_K, H_K, `k${c + 1}`, 'k', null, c);
        }

        for (let r = 0; r < TOKENS; r++) {
          block(g, X.V, m.vT + r * H_QVO, W_QVO, H_QVO, `v${r + 1}`, 'v', r);
        }
      });

      const arrows = svg.append('g');
      const ARROW_MARGIN = 8; // Add small margin between blocks and arrows
      const K_L = X.K - ARROW_MARGIN, K_R = X.K + TOKENS * W_K + ARROW_MARGIN, M_L = X.M - ARROW_MARGIN, M_R = X.M + TOKENS * CELL + ARROW_MARGIN, V_L = X.V - ARROW_MARGIN, V_R = X.V + W_QVO + ARROW_MARGIN, O_L = X.O - ARROW_MARGIN;
      const grp = h => Math.floor(h / hpg);

      for (let h = 0; h < HEADS; h++) {
        const y = h * (HEAD_HEIGHT + HEAD_MARGIN) + 30, mid = qCenterY(y), m = meta[grp(h)];
        const g = grp(h);
        const headInGroup = h - m.h0; // Position of this head within its group
        const totalHeadsInGroup = m.h1 - m.h0 + 1; // Total heads in this group

        // Add small vertical offset for multiple arrows to same KV group
        const arrowOffset = totalHeadsInGroup > 1 ? (headInGroup - (totalHeadsInGroup - 1) / 2) * 12 : 0;

        addA(arrows, X.Q + W_QVO + ARROW_MARGIN, mid, K_L, m.kC + arrowOffset);
        addA(arrows, M_R, mid, V_L, m.kC + arrowOffset);
        addA(arrows, V_R, m.kC + arrowOffset, O_L, mid);
      }

      meta.forEach(m => {
        for (let h = m.h0; h <= m.h1; h++) {
          const headInGroup = h - m.h0;
          const totalHeadsInGroup = m.h1 - m.h0 + 1;
          const arrowOffset = totalHeadsInGroup > 1 ? (headInGroup - (totalHeadsInGroup - 1) / 2) * 6 : 0;

          addA(arrows, K_R, m.kC + arrowOffset, M_L, qCenterY(h * (HEAD_HEIGHT + HEAD_MARGIN) + 30));
        }
      });

      update();
    }

    /************** Highlight **************/
    function resetFade() {
      svg.selectAll('rect').classed('fade', true);
    }

    function clearHL() {
      svg.selectAll('.rect').attr('class', function () {
        return this.getAttribute('class').split(' ')[0] + ' rect';
      });
      svg.selectAll('.cache-overlay').style('display', 'none');
      // Reset opacity
      svg.selectAll('.rect').style('opacity', null);
    }

    function update() {
      resetFade();
      clearHL();

      const w = win();
      const hpg = HEADS / groups;
      const grp = h => Math.floor(h / hpg);

      // Compute output opacities for all heads and steps if opacity mode is on
      let outputOpacities = null;
      if (opacityMode) {
        outputOpacities = computeAllOutputOpacities(w, attentionSinks);
      }

      for (let h = 0; h < HEADS; h++) {
        const sel = `.h${h}`;
        svg.selectAll(`${sel} .q.rect[data-r='${step}']`).classed('fade', false).classed('q-highlight', true);
        svg.selectAll(`${sel} .o.rect[data-r='${step}']`).classed('fade', false).classed('o-highlight', true);

        svg.selectAll(`${sel} .q.rect`).each(function () {
          const r = +this.dataset.r;
          if (kvCache) {
            if (r === step) {
              d3.select(this).classed('fade', false).classed('q-highlight', true);
              // Apply opacity for current query if opacity mode is on
              if (opacityMode && r < queryOpacities.length) {
                const opacity = queryOpacities[r][h];
                d3.select(this).style('opacity', opacity);
              }
              return;
            }
          } else {
            if (r <= step) {
              d3.select(this).classed('fade', false).classed('q-highlight', true);
              // Apply opacity for queries if opacity mode is on
              if (opacityMode && r < queryOpacities.length) {
                const opacity = queryOpacities[r][h];
                d3.select(this).style('opacity', opacity);
              }
            }
          }
        });

        svg.selectAll(`${sel} .o.rect`).each(function () {
          const r = +this.dataset.r;
          if (kvCache) {
            if (r === step) {
              d3.select(this).classed('fade', false).classed('o-highlight', true);
              // Apply opacity for output if opacity mode is on
              if (opacityMode && outputOpacities && r < outputOpacities[h].length) {
                const opacity = outputOpacities[h][r];
                d3.select(this).style('opacity', opacity);
              }
              return;
            }
          } else {
            if (r <= step) {
              d3.select(this).classed('fade', false).classed('o-highlight', true);
              // Apply opacity for output if opacity mode is on
              if (opacityMode && outputOpacities && r < outputOpacities[h].length) {
                const opacity = outputOpacities[h][r];
                d3.select(this).style('opacity', opacity);
              }
            }
          }
        });

        svg.selectAll(`${sel} .m.rect`).each(function () {
          const r = +this.dataset.r, c = +this.dataset.c;

          // Mark masked (future) positions with light gray
          if (c > r) {
            d3.select(this).classed('fade', false).classed('masked', true);
            return;
          }

          // Apply sliding window constraint to attention matrix only
          const windowStart = Math.max(0, r - w + 1);
          const inWindow = c >= windowStart && c <= r && r <= step;

          // Check if position is within attention sinks range (only for computed rows)
          const inAttentionSinks = w !== Infinity && c < attentionSinks && r <= step;

          // Mark positions outside sliding window (left bottom) with light gray, except for attention sinks
          if (w !== Infinity && c < windowStart && r <= step && !inAttentionSinks) {
            d3.select(this).classed('fade', false).classed('masked', true);
            return;
          }

          if (kvCache) {
            if (r === step && (inWindow || inAttentionSinks)) {
              // In KV cache mode, attention matrix is always newly computed (not cached)
              // So use highlight color, not cache color
              d3.select(this).classed('fade', false).classed('m-highlight', true);

              // Apply opacity for attention if opacity mode is on
              if (opacityMode) {
                const attentionOpacities = computeAttentionOpacities(h, step, w, attentionSinks);
                if (r < attentionOpacities.length && c < attentionOpacities[r].length && attentionOpacities[r][c] > 0) {
                  d3.select(this).style('opacity', attentionOpacities[r][c]);
                }
              }
            }
          } else {
            if (inWindow || inAttentionSinks) {
              d3.select(this).classed('fade', false).classed('m-highlight', true);

              // Apply opacity for attention if opacity mode is on
              if (opacityMode) {
                const attentionOpacities = computeAttentionOpacities(h, step, w, attentionSinks);
                if (r < attentionOpacities.length && c < attentionOpacities[r].length && attentionOpacities[r][c] > 0) {
                  d3.select(this).style('opacity', attentionOpacities[r][c]);
                }
              }
            }
          }
        });
      }

      for (let g = 0; g < groups; g++) {
        const kv = `.g${g}`;

        svg.selectAll(`${kv} .k.rect`).each(function (_, i) {
          // Keys are available up to current step
          const inRange = i <= step;
          if (inRange) {
            // In KV cache mode with sliding window, don't show cached keys that are outside the window and not in attention sinks
            if (kvCache && w !== Infinity) {
              const windowStart = Math.max(0, step - w + 1);
              const inAttentionSinks = i < attentionSinks;
              if (i < windowStart && !inAttentionSinks) {
                // This key is cached but outside the sliding window and not in attention sinks, so don't highlight it
                return;
              }
            }

            const cls = i === step ? 'k-highlight' : kvCache ? 'k-cache' : 'k-highlight';
            d3.select(this).classed('fade', false).classed(cls, true);

            // Apply opacity for keys if opacity mode is on
            if (opacityMode && i < keyOpacities.length) {
              // Determine which head's opacity to use based on groups setting
              let headIndex;
              if (groups === 4) {
                // MHA: each group has 1 head, use the head index directly
                headIndex = g;
              } else if (groups === 2) {
                // GQA: head 1,2 use head1 (index 0), head 3,4 use head3 (index 2)
                headIndex = g === 0 ? 0 : 2;
              } else if (groups === 1) {
                // MQA: all heads use head1 (index 0)
                headIndex = 0;
              }

              if (headIndex < keyOpacities[i].length) {
                const opacity = keyOpacities[i][headIndex];
                d3.select(this).style('opacity', opacity);
              }
            }

            // Show cache pattern for cached K elements
            if (kvCache && i < step) {
              const overlay = svg.selectAll(`${kv} .k.cache-overlay[data-c='${i}']`);
              overlay.style('display', 'block');

              // In opacity mode, add class for more subtle pattern
              if (opacityMode) {
                overlay.classed('opacity-mode', true);
              } else {
                overlay.classed('opacity-mode', false);
              }
            }
          }
        });

        svg.selectAll(`${kv} .v.rect`).each(function (_, r) {
          // Values are available up to current step
          const inRange = r <= step;
          if (inRange) {
            // In KV cache mode with sliding window, don't show cached values that are outside the window and not in attention sinks
            if (kvCache && w !== Infinity) {
              const windowStart = Math.max(0, step - w + 1);
              const inAttentionSinks = r < attentionSinks;
              if (r < windowStart && !inAttentionSinks) {
                // This value is cached but outside the sliding window and not in attention sinks, so don't highlight it
                return;
              }
            }

            const cls = r === step ? 'v-highlight' : kvCache ? 'v-cache' : 'v-highlight';
            d3.select(this).classed('fade', false).classed(cls, true);

            // Apply opacity for values if opacity mode is on
            if (opacityMode && r < valueOpacities.length) {
              // Determine which head's opacity to use based on groups setting
              let headIndex;
              if (groups === 4) {
                // MHA: each group has 1 head, use the head index directly
                headIndex = g;
              } else if (groups === 2) {
                // GQA: head 1,2 use head1 (index 0), head 3,4 use head3 (index 2)
                headIndex = g === 0 ? 0 : 2;
              } else if (groups === 1) {
                // MQA: all heads use head1 (index 0)
                headIndex = 0;
              }

              if (headIndex < valueOpacities[r].length) {
                const opacity = valueOpacities[r][headIndex];
                d3.select(this).style('opacity', opacity);
              }
            }

            // Show cache pattern for cached V elements
            if (kvCache && r < step) {
              const overlay = svg.selectAll(`${kv} .v.cache-overlay[data-r='${r}']`);
              overlay.style('display', 'block');

              // In opacity mode, add class for more subtle pattern
              if (opacityMode) {
                overlay.classed('opacity-mode', true);
              } else {
                overlay.classed('opacity-mode', false);
              }
            }
          }
        });
      }

      d3.select('#step-display').text(`Step: ${step + 1}`);
    }

    /************** Timer **************/
    function run() {
      timer && timer.stop();
      timer = d3.interval(() => {
        if (playing) {
          step = (step + 1) % TOKENS;
          update();
        }
      }, 1400);
    }

    /************** Controls **************/
    d3.select('#play-btn').on('click', () => {
      playing = !playing;
      d3.select('#play-btn').text(playing ? '⏸ Pause' : '▶ Play');
    });

    d3.select('#opacity-btn').on('click', () => {
      opacityMode = !opacityMode;
      d3.select('#opacity-btn').text(`Opacity: ${opacityMode ? 'ON' : 'OFF'}`);
      update();
    });

    d3.select('#cache-btn').on('click', () => {
      kvCache = !kvCache;
      d3.select('#cache-btn').text(`KV Cache: ${kvCache ? 'ON' : 'OFF'}`);
      d3.select('#cache-explanation').style('visibility', kvCache ? 'visible' : 'hidden');
      update();
    });

    d3.select('#groups-select').on('change', function () {
      groups = +this.value;
      drawLayout();
    });

    d3.select('#window-select').on('change', function () {
      winSetting = this.value;

      // Update attention sinks options based on sliding window setting
      const sinksSelect = d3.select('#sinks-select');
      sinksSelect.selectAll('option').remove();

      if (winSetting === 'all') {
        sinksSelect.attr('disabled', true);
        sinksSelect.append('option').attr('value', '0').attr('selected', true).text('0');
        attentionSinks = 0;
      } else {
        sinksSelect.attr('disabled', null);
        const maxSinks = TOKENS - parseInt(winSetting);
        for (let i = 0; i <= maxSinks; i++) {
          const option = sinksSelect.append('option').attr('value', i).text(i);
          if (i === 0) option.attr('selected', true);
        }
        attentionSinks = 0;
      }

      update();
    });

    d3.select('#sinks-select').on('change', function () {
      attentionSinks = +this.value;
      update();
    });

    /************** Init **************/
    drawLayout();
    run();
  </script>
</body>

</html>